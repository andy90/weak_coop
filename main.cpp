#include <iostream>
#include <vector>
#include <map>
#include <list>
#include <ctime>
#include <algorithm>
#include <fstream>
#include <string>
#include "constants.h"
#include "names.h"
#include "Organism.h"
#include "usefulfunctions.h"
#include "array_functions.h"

int main() {
    using namespace std;
    random_device rd;
    auto seed1 = rd();
    auto seed2 = rd();
    Rand_engine generator(seed1); // use 0 as seed makes sure the same random number is generated every time. if want different number everytime, try to use time(NULL) as seed.
    Rand_engine generator_fixed(seed2); // use the fixed generator for generating the initial coordinates of the task and the component. One generator is for tasks. The other is for components

    ofstream fseed("seed.txt");
    fseed << seed1 << " " << seed2 << "\n";
    fseed.close();

    // construct the initial task. It is shared by all the organisms
    int M = 1; // initial number of tasks    
    Comp_Task tasks;
    for (int i = 0; i<M; i++) { // initialize tasks
        vector<double> r = array_unidis(-sigma_task, sigma_task, D, generator_fixed);
        tasks.insert(pair<int, vector<double> >(i, r));  // the initial tasks are uniformly distributed in a D-dim box, range from -sigma_task to sigma_task
    }

    int N = 1; // initial number of comp
    Comp_Task components;
    for (int i = 0; i<N; i++) { // initialize components
        uniform_real_distribution<double> uni_dis(0, dis_theta2); // decide the distance of the initial component
        double disloc = uni_dis(generator);
        vector<double> r = generate_delta(disloc, D, generator);
        vector<double> comp_new(D);
        int itask = i % M;
        for (int j = 0; j<D; j++) {
            comp_new[j] = tasks[itask][j] + r[j]; // the components are displaced slightly from the tasks
        }
        components.insert(pair<int, vector<double> >(i, comp_new));
    } 

    Organism a(components, tasks, 1, Norg);

    list<Organism> organisms;
    organisms.push_back(a);

    
    
    ofstream task_completion("tc.txt");
    task_completion << "#step M M_nc M_w M_spe_coop M_spe M_coop\n";
    ofstream mutantfrac("mfrac.txt"); // store the fraction of mutant after the new task is added.
    ofstream mutationdis("mdis.txt"); // the mutation distance of the current generation from the initial generation.
    ofstream ntE_status("ntE.txt"); // this how each task is completed as time goes
    ofstream trj("traj.txt"); // write out the most probable trajectory
    ofstream Nav("Nav.txt"); // records the average number of components
    ofstream cost_av("cost.txt"); // record the cost change before and after adding the new task
    ofstream cluster_size("c_size.txt");
    cluster_size << "#step 0 1 2 3 ... 20\n";
    ofstream res("res.txt");// writeout the end of the response
    res << M << " " << 0<<" "; // this records the initial point
    int Mtotal = 40;
    int Nsteps_write = 1000;
    int Nsteps_writeresponse = 20;

    vector<double> res_end(Mtotal+1, -100); // an extra one is used to take into account some artifact case (avoid indexing res(Mtotal) error, which is possible).
    vector<double> res_begin(Mtotal+1, 0);
    int Nsteps_addtask = -1000;
    int isteps = 0;
    while(M<=Mtotal) {
        int flag_addtask = 0; // this flag will be one if a new task is added in.
        if (isteps == Nsteps_addtask) {
            flag_addtask = 1;
            cost_av << isteps << " ";
            write_cost_av(organisms, cost_av); // write the free energy before change
            uniform_real_distribution<double> uni_dis(0, 1); // decide whether to use the large distance or small distance
            vector<double> task_new(D); // stores the position of the new task

            if (uni_dis(generator_fixed)<0.00) {
                double d = 1.2*dis_theta2;
                double flag = 1;
                while (flag>0.5) {
                    flag = 0;
                    vector<double> delta_comp_ic = generate_delta(d, D, generator_fixed);
                    for (int j = 0; j < D; j++) {
                        task_new[j] = tasks[M - 1][j] + delta_comp_ic[j]; // the new task is generated by making displacement to the task generated last time
                    }

                    if (M>1) {
                        for (int j = 0; j<(M - 1); j++) {
                            if (normsquare(task_new, tasks[j])<(d*d)) {
                                flag = 1; // if the new task still overlaps with another one other than the one generated last time, we should find a new one
                                continue;
                            }
                        }
                    }
                }
            }
            else {
                double d = 1.8*dis_theta2; // this is the default distance between tasks
                vector<double> delta_comp_ic = generate_delta(d, D, generator_fixed);
                uniform_int_distribution<int> uni_int2(0, M - 1);
                int iM = uni_int2(generator_fixed); // the new task should be connected to a randomly selected task
                for (int j = 0; j < D; j++) {
                    task_new[j] = tasks[iM][j] + delta_comp_ic[j]; // the new task is generated by making displacement to the task generated last time
                }

            }

            tasks.insert(pair<int, vector<double> >(M, task_new)); // insert the new task
            M = M + 1; // update the number of tasks

            for (auto i_organism = organisms.begin(); i_organism != organisms.end(); i_organism++) {
                i_organism->add_task(tasks);
            }
            

            write_cost_av(organisms, cost_av); // write the free energy after change
            cost_av << "\n";

            res_begin[M - 1] = isteps; // record the step of adding the tasks
            if (M <= Mtotal) {
                res << M << " " << res_begin[M - 1] << " ";
            }
        }
        if (isteps%Nsteps_write == 0) {
            task_completion << isteps << " " << M << " ";
            write_completion_status(organisms, task_completion);
            write_traj_mostprob(organisms, trj, isteps);
            Nav << isteps << " ";
            writeN(organisms, Nav);
            cluster_size << isteps << " ";
            write_csize_av(organisms, cluster_size);
        }
        if (isteps%Nsteps_writeresponse == 0) {
        
            mutationdis << isteps << " " << M << " ";
            write_mutations(organisms, mutationdis);
            ntE_status << isteps << " ";
            vector<double> ntE_av=write_ntE_av(organisms, M, ntE_status); // when couple the results of mutationdis and ntE_status, we can see how many mutations it takes to complete each task
            if ((ntE_av[M - 1] > 0.8) && (res_end[M - 1] < 0)) {
                res_end[M - 1] = isteps;
                Nsteps_addtask = isteps + 50000;
                if (M <= Mtotal) {
                    res << res_end[M - 1] << "\n";
                }
            }
        }
        if (isteps==(Nsteps_addtask-1000)) {
            ofstream crossdis("crossdis" + to_string(isteps) + ".txt"); // write the cross reactivity of the component and the average distance between tasks
            write_cross_dis_all(organisms, crossdis);
        }

        if (isteps%Nsteps_writeresponse == 0) { // if this step is when we want to write out data
            mutantfrac << isteps<<" "<<M << " ";
            mutateresample(organisms, generator, mutantfrac);
        }
        else {
            mutate(organisms, generator);
            resample(organisms, generator);
        }
        isteps++;
    }
    
    
    // writeout the tasks
    ofstream task_data("tasks.txt");
    task_data << "#id x y\n";
    for (int i = 0; i < M; i++) {
        task_data << i << " ";
        for (int j = 0; j < D; j++) {
            task_data << tasks[i][j] << " ";
        }
        task_data << "\n";
    }
    
    
    
    return 0;
}




